#def tag âŸ¨#Direction down up across â²pass throughâ³âŸ©
#def tag âŸ¨#Input inâŸ©
#def tag âŸ¨#Output outâŸ©
#def dtype âŸ¨Sender component portâŸ©
#def dtype âŸ¨Receiver component portâŸ©
#def dtype âŸ¨MessageWithoutDebug port dataâŸ©
#def dtype âŸ¨Message port data origin trailâŸ©
#def dtype âŸ¨Connection direction sender receiverâŸ©
#def tag âŸ¨#YesNo yes noâŸ©
#def dtype âŸ¨Data ValueâŸ©
#def dtype Value = âŸ¨#YesNoâŸ© | * 

#def constructor Container (ğœŒchildrenArray ğœŒmap) 
    {âœ¦armed âœ¦completed}
{
    Å¡.reset â‰£ Å¾reset
    Å¡.â²completed ?â³ â‰£ Î»â²completed ?â³
    Å¡.handle â‰£ Î»handle
    Å¡.step â‰£ Î»step
    Å¡.setChildren â‰£ Î»setChildren
    Å¡.setRoutings â‰£ Î»setRoutings
    Å¡/â²clear outputsâ³

    /* helper functions */
    Å¡.acceptInput â‰£ Å¾acceptInput
    Å¡.mergeOutputs â‰£ Î»mergeOutputs
    Å¡.route â‰£ Å¾route
    Å¡.runToCompletion â‰£ Å¾runToCompletion

    Å¡.children â‰£ ğœŒchildrenArray
    Å¡/â²set parent of childrenâ³ (Å¡)
    Å¡.routingMap â‰£ ğœŒmap
}

#def procedure â²clear outputsâ³ {
  #lang js (self) Â«
    self.outputs = [];
  Â»
}


#def procedure â²set parent of childrenâ³ {
  #lang js (self) Â«
    self.children.forEach (child => {
        child.container = self;
    });
  Â»
}

#def procedure reset () {
  /* reset the state of self and all children */
  âˆ€ Å¡.children ğœchild {
    ğœchild/reset
  }
}

#def function â²completed ?â³ {
  #lang js (self) Â«
    var done = true;
    self.children.forEach (child => {
        done = done & child.completed___Q ();
    });
    return done;
  Â»
}

#def procedure handle (ğœŒmessage) {
    Å¡/reset
    #? Å¡ {
        #? Å¡ âœ¦completed {
            die 'internal error: container.handle called on completed container'
        } 
        #? Å¡ âœ¦armed {}
    }
    Å¡/acceptInput (ğœŒmessage)
    #inner function send (ğœŒport ğœŒdata) {
        Å¡.outputs/push (âŸ¨Message ğœŒport ğœŒdata Å¡ ğœŒmessageâŸ©)
    }
    Å¡/runToCompletion (Å¾send)
    Å¡.outputs/push (âŸ¨Message â—¦out Ï• Å¡ ğœŒmessageâŸ©)
}

#private procedure acceptInput (ğœŒmessage) {
    Å¡/â²clear outputsâ³
    âˆ€ Å¡.routingMap ğœconnection {
        #? âŸ¨#DirectionâŸ© ğœconnection {
          #? âŸ¨#DirectionâŸ© âŸ¨#Direction downâŸ© {
            #synonym childOutputs â‰£ ğœconnection.receiver/handle (âŸ¨Message ğœconnection.port ğœŒmessage.data Å¡ ğœŒmessageâŸ© Å¾sendProcedure) {
                Å¡/mergeOutputs (childOutputs)
            }
          }
          #? âŸ¨#DirectionâŸ© âŸ¨#Direction â²pass throughâ³âŸ© {
            #synonym childOutputs â‰£ [âŸ¨MessageâŸ©âŸ¨Message ğœconnection.port ğœŒmessage.data Å¡ ğœŒmessageâŸ©] {
                Å¡/mergeOutputs (childOutputs)
            }
          }
          #? âŸ¨#DirectionâŸ© âŸ¨#Direction acrossâŸ© {}
	  #? âŸ¨#DirectionâŸ© âŸ¨#Direction upâŸ© {}
        }
    }
}

#private function mergeOutputs (ğœŒchildOutputs) {
    /* merge childOutputs with self.outputs in situ */
    /* outputs & childOutputs are queues
       copy from least recent to most recent */
  #lang js (childOutputs) â€œ
    var clonedOuts = Array.from (self.outputs);
    var childOuts = childOutputs.reverse ();
    childOuts.forEach (cout => {
        clonedOutputs.push (cout);
    });
    return clonedOutputs;
  â€
}

#private procedure runToCompletion (ğœŒsendProcedure) {
     #lang js Â«
         while (! Â«Å¡/completedÂ») {
             Â«Å¡/step (ğœŒsendProcedure)Â»
             Â«Å¡/route (ğœŒsendProcedure)Â»
         }
     Â»
     #lang cl Â«
         (loop while (not Â«Å¡/completedÂ»)
             do (progn Â«Å¡/step (ğœŒsendProcedure)Â»
                       Â«Å¡/route (ğœŒsendProcedure)Â»))
     Â»
}

#def procedure step (ğœŒsendProcedure) {
    âˆ€ Å¡.children ğœchild {
        ğœchild/step (ğœŒsendProcedure)
    }
}

#def function route (ğœŒsendProcedure) {
    #synonym â²deferred message stackâ³ â‰£ [âŸ¨MessageâŸ©] {
        âˆ€ Å¡.routingMap ğœconnection {
            #? âŸ¨#DirectionâŸ© ğœconnection.direction {
                #? âŸ¨#DirectionâŸ© âŸ¨#Direction acrossâŸ© {
                    #synonym â²output messageâ³ â‰£ ğœconnection.sender.outputs {
                        â²deferred message stackâ³/push (âŸ¨Dest connection.receiver connection.port â²output messageâ³âŸ©)

                    }
                }
                #? âŸ¨#DirectionâŸ© âŸ¨#Direction upâŸ© {
		    /* same as across, above */
                    #synonym â²output messageâ³ â‰£ ğœconnection.sender.outputs {
                        â²deferred message stackâ³/push (âŸ¨Dest connection.receiver connection.port â²output messageâ³âŸ©)

                    }
                }
                #? âŸ¨#DirectionâŸ© âŸ¨#Direction downâŸ© {}
		#? âŸ¨#DirectionâŸ© âŸ¨#Direction â²pass throughâ³âŸ© {}
            }
        }
        âˆ€ â²deferred message stackâ³ ğœdest {
	    #synonym m â‰£ âŸ¨Message ğœdest.port ğœdest.message.data Å¡ ğœdest.messageâŸ© {
                ğœdest.target/handle (m ğœŒsendProcedure)
            }
        }
    }
}







