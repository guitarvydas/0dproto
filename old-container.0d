dtype âŸ¨Dest target port messageâŸ©
tag âŸ¨#Direction down up across â²pass throughâ³âŸ©

constructor Container (ğœŒchildrenArray ğœŒmap) 
    {âœ¦armed âœ¦completed}
    {â–«across â–«up â–«down â–«passThrough}
{
    Å¡.reset â‰£ Å¾reset
    Å¡.â²completed ?â³ â‰£ Î»â²completed ?â³
    Å¡.handle â‰£ Î»handle
    Å¡.step â‰£ Î»step
    Å¡.setChildren â‰£ Î»setChildren
    Å¡.setRoutings â‰£ Î»setRoutings
    Å¡.outputs â‰£ []

    /* helper functions */
    Å¡.acceptInput â‰£ Å¾acceptInput
    Å¡.mergeOutputs â‰£ Î»mergeOutputs
    Å¡.route â‰£ Å¾route
    Å¡.runToCompletion â‰£ Å¾runToCompletion

    Å¡.children â‰£ ğœŒchildrenArray
    Å¡/â²set parent of childrenâ³ (Å¡)
    Å¡.routingMap â‰£ ğœŒmap
}

#declare procedure â²set parent of childrenâ³ {
  #lang js (self) Â«
    self.children.forEach (child => {
        child.container = self;
    });
  Â»
}

procedure reset () {
  âˆ€ Å¡.children ğœchild {
    ğœchild/reset
  }
}

#declare function â²completed ?â³ {
  #lang js (self) Â«
    var done = true;
    self.children.forEach (child => {
        done = done & child.completed___Q ();
    });
    return done;
  Â»
}

procedure handle (ğœŒmessage) {
    Å¡/reset
    #state? Å¡ {
        âœ¦completed {
            die 'internal error: container.handle called on completed container'
        } 
        âœ¦armed {}
    }
    Å¡/acceptInput (ğœŒmessage)
    #inner function send (ğœŒport ğœŒdata) {
        Å¡.outputs/push (âŸªğœŒport ğœŒdata Å¡ ğœŒmessageâŸ«)
    }
    Å¡/runToCompletion (Å¾send)
    Å¡.outputs/push (âŸªâ—¦out Ï• Å¡ ğœŒmessageâŸ«)
}

#internal procedure acceptInput (ğœŒmessage) {
    #clear Å¡.outputs
    âˆ€ Å¡.routingMap ğœconnection {
        #tag? Direction ğœconnection {
          â–«down {
            synonym childOutputs â‰£ ğœconnection.receiver/handle (âŸªğœconnection.port ğœŒmessage.data Å¡ ğœŒmessageâŸ« Å¾sendProcedure) {
                Å¡/mergeOutputs (childOutputs)
            }
          }
          â–«passthrough {
            synonym childOutputs â‰£ [âŸªğœconnection.port ğœŒmessage.data Å¡ ğœŒmessageâŸ«] {
                Å¡/mergeOutputs (childOutputs)
            }
          }
          â–«across â–«up {}
        }
    }
}

#internal function mergeOutputs (ğœŒchildOutputs) {
    /* merge childOutputs with self.outputs in situ */
    /* outputs & childOutputs are queues
       copy from least recent to most recent */
  #lang js (childOutputs) Â«
    var clonedOuts = Array.from (self.outputs);
    var childOuts = childOutputs.reverse ();
    childOuts.forEach (cout => {
        clonedOutputs.push (cout);
    });
    return clonedOutputs;
  Â»
}

#internal procedure runToCompletion (ğœŒsendProcedure) {
     ##js Â«
         while (! Â«Å¡/completedÂ») {
             Â«Å¡/step (ğœŒsendProcedure)Â»
             Â«Å¡/route (ğœŒsendProcedure)Â»
         }
     Â»
     ##cl Â«
         (loop while (not Â«Å¡/completedÂ»)
             do (progn Â«Å¡/step (ğœŒsendProcedure)Â»
                       Â«Å¡/route (ğœŒsendProcedure)Â»))
     Â»
}

procedure step (ğœŒsendProcedure) {
    âˆ€ Å¡.children ğœchild {
        ğœchild/step (ğœŒsendProcedure)
    }
}

function route (ğœŒsendProcedure) {
    synonym â²deferred message stackâ³ â‰£ [] {
        âˆ€ Å¡.routingMap ğœconnection {
            #tag? Direction ğœconnection.direction {
                â–«across â–«up {
                    synonym â²output messageâ³ â‰£ ğœconnection.sender.outputs {
                        â²deferred message stackâ³/push (âŸ¨Dest connection.receiver connection.port messageâŸ©)

                    }
                }
                â–«down â–«passThrough {}
            }
        }
        âˆ€ â²deferred message stackâ³ ğœdest {
	    synonym m â‰£ âŸªğœdest.port ğœdest.message.data Å¡ ğœdest.messageâŸ« {
                ğœdest.target/handle (m ğœŒsendProcedure)
            }
        }
    }
}

