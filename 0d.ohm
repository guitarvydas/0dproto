Forward {
  // these must be redefined (":=") in the final grammar
  main = "forward"
  Expression = "forward"
  name = "forward
}

BasicComment {
  comment =  "/*" commentInnards* "*/"
  commentInnards =
    | "/*" commentInnards* "*/" -- rec
    | ~"/*" ~"*/" any -- flat

  space += comment
}

oBasicVerbatim {
  verbatim = verbatimBegin verbatimInnards+ verbatimEnd
  verbatimInnards =
    | verbatimBegin expr verbatimEnd -- switchGrammars
    | ~verbatimBegin ~verbatimEnd any -- flat
  expr = applySyntactic<Expression>
}

BasicCodeSnippets {
  snippetPrefix = "##"
}

BasicString {
  string = sq (~sq any)* sq
  sq = "'"
}

BasicKeywordPrefix {
  kp = "#"
}

BasicPrefixes {
  lambdaPrefix = "Î»"
  procedurePrefix = "Å¾"
  statePrefix = "âœ¦"
  parameterPrefix = "ğœŒ"
}

BasicUnaryOperators {
  new = "â†µ"
  call = "/"
  self = "Å¡"
  phi = "Ï•"
  temp = "ğœ"
  forAll = "âˆ€"
  query = "#?" 
  defineop = "â‰£"
}

BasicBinaryOperator {
  dot = "."
}

BasicBrackets {
  messageBegin = "âŸª"
  messageEnd = "âŸ«"
  verbatimBegin = "Â«"
  verbatimEnd = "Â»"
  compoundNameBegin = "â²"
  compoundNameEnd = "â³"
  dtypeBegin = "âŸ¨"
  dtypeEnd = "âŸ©"
  tagBegin = "âŸ¨#"
  tagEnd = "âŸ©"

  nameBracket = compoundNameBegin | compoundNameEnd
  dtypeBracket = dtypeBegin | dtypeEnd
  messageBracket = messageBegin | messageEnd
  verbatimBracket = verbatimBegin | verbatimEnd
  tagBracket = tagBegin | tagEnd
  
  bracket =
    | "(" | ")" | "{" | "}" | "[" | "]" | "<" | ">"
    | nameBracket | dtypeBracket | messageBracket | verbatimBracket | tagBracket

}

BasicDelimiter {
  delimiter = bracket | unaryOperator | kp
}

BasicKeywords <: BasicKeywordPrefix {
  // keyword prefix - strictly not necessary, but helps with visual inspection during bootstrap
  
  yes = kp "yes"
  no = kp "no"
  def = kp "def"
  synonym = kp "synonym"

  keyword = yes | no | def
}

BasicTag {
  tagName = "âŸ¨#" name "âŸ©"
  tagDefinition = "âŸ¨#" name name+ "âŸ©"
  tag = 
    | "âŸ¨#" name Expression "âŸ©"
    | "âŸ¨#" name name "âŸ©"
}

BasicDtype {
  dtypeName = "âŸ¨" name "âŸ©"
  dtypeDefinition = "âŸ¨#" name name+ "âŸ©"
  dtype =
    | "âŸ¨#" name Expression "âŸ©"
    | "âŸ¨#" name name "âŸ©"
}

BasicList {
  listEnd = "]"
  dtypeListBegin = "[âŸ¨"
  tagListBegin = "[âŸ¨#"
  genericListBegin = "["
  dtypeList = dtypeListBegin Expression* listEnd
  tagList = tagListBegin Expression* listEnd
  genericList = genericListBegin Expression* listEnd
}


Name {
  name =
    | compoundName -- compoundName
    | self -- self
    | phi -- null
    | basicName -- basicName

  compoundName = "â²" (~nameBracket any)* "â³"
  basicName = nameFirst nameRest*
  nonSpecialName = ~self ~keyword name
  
  nameFirst = letter | "_"
  nameRest = alnum | "_"

}

Operator {
  queryState = query state
  queryDtype = query dtypeName
  queryTag = query tagName
  forall = forAll
  unaryOperator = new | lambda | proc | call | state | self | phi | temp  | parameter
    | forAll
    | kp
  binaryOperator = dot
}

ParameterList <: Forward {
  FormalParameterList = "(" pname* ")"
  ActualParameterList = "(" Expression* ")"
  pname = parameterPrefix name
}

StateList <: Forward {
  PossibleStates = "{" sname+ "}"
  sname = statePrefix name
}

Block {
  Block = "{" Expression* "}"
}

Synonym {
  SynonymScopedBlock = synonym name defineop Block
}
  

GrammarBackbone <: ??? {
}

ZeroD <: GrammarBackBone {
  main := definition+

  Definition = dtypeDefinition | tagDefinition | functionDefinition | procedureDefinition
    | ConstructorDefinition
    
  functionDefinition = def "function" FormalParameters Block
  procedureDefinition = def "procedure" FormalParameters Block
  ConstructorDefinition = def "constructor" FormalParameters PossibleStates Block

  ConstructionExpression = ConstructorFieldAssign | Expression

  ConstructorFieldAssign = selfFieldName defineop Expression

  Expression =
    | forallExpression
    | stateUpdateExpression
    | stateQueryExpression
    | dtypeQueryExpression
    | tagQueryExpression
    | verbatim
    | primary

primary = 
  | self call name -- methodCallOfSelf
  | primary call name -- methodCallOfPrimary
  | self (dot name)? -- fieldOfSelf
  | primary (dot name)? -- fieldOfPrimary
  | temporary name -- temp
  | lambdaPrefix name -- function
  | procedurePrefix name -- procedure
  | parameterPrefix name -- parameter
  | statePrefix name -- state
  | new primary -- instantiation
  | phi -- null
  | messageBegin primary primary primary primary -- messageWithDebugInfo
  | messageBegin primary primary -- messageWithoutDebugInfo
  | dtype -- dtype
  | tag -- tag
  | dtypeList -- dtypeList
  | tagList -- tagList
  | genericList -- genericList
}
